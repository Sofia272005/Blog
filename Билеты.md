1. ==Понятие открытой системы (в широком и узком смысле).==
В разных источниках можно найти различные трактовки термина, которые могут себя назвать либо как определение «в широком смысле», либо — «в узком смысле».

- Открытые системы — это системы, которые нельзя считать закрытыми по отношению к окружающей среде в каком-либо аспекте — информационном, вещественном, энергетическом и т. д. Открытые системы могут обмениваться веществом, энергией, информацией с окружающей средой. Это наиболее общее определение и оно подходит к общей теории систем, биологии, кибернетике, информатике, экономике и в других областях, поскольку их связи со средой имеют первостепенное значение при их описании и моделировании.
- Системы являются открытыми, если они построены по модульному принципу и открыты для расширения своей функциональности и для связи с другими системами не путём своей основательной переделки, но за счёт 4 возможности добавления в них новых модулей, реализующих новые функции, или замены одних модулей другими. Это определение позволяет считать очень большое количество систем открытыми, поскольку модульный подход к созданию систем является одним из основных и самых распространённых, и он позволяет изменять и/или расширять возможности систем. Действительно, модульность вытекает из желания упростить создание системы и иметь возможности по замене частей системы (т. е. модулей) аналогичными изделиями других производителей.
- Под открытостью системы иногда понимают ее соответствие современным промышленным стандартам, которое обеспечивает возможность интеграции с другими открытыми системами. Соответствие стандартам необходимо для обеспечения совместимости модулей и систем. Но это достаточно узкое толкование, оно учитывает далеко не все свойства открытых систем.
- С точки зрения итологии — науки, изучающей информационные технологии — сущность технологии открытых систем состоит в следующем: 
	- в обеспечении унифицированного обмена данными между различными компьютерами и платформами, на которых создаётся система;
	-  в переносимости приложений (прикладных программ) между различными платформами; 
	-  в мобильности пользователей, т.е. возможности пользователей переходить с одного компьютера на другой независимо от его архитектуры и установленного программного обеспечения без необходимости переобучения специалистов.
- Наиболее полное и исчерпывающее определение дал Комитет IEEE POSIX 1003.0. Открытая система — это такая система, которая создаётся по определённым стандартам. Эти стандарты включают правила для:

	1. **Интерфейсов** — как система взаимодействует с программами.
	2. **Сервисов** — какие функции система предоставляет.
	3. **Форматов данных** — как информация хранится и обрабатывается.
	
	Главная цель таких стандартов — сделать системы гибкими и удобными. Это позволяет:
	
	- Переносить программы с одной системы на другую с минимальными изменениями.
	- Обеспечивать совместную работу разных приложений, даже если они находятся на разных компьютерах.
	- Создавать удобный интерфейс для пользователя, чтобы он легко адаптировался при работе с разными системами.
Таким образом получается, что наиболее общее толкование термина «Открытая система» сводится к тому, что это система, состоящая из модулей, которые взаимодействуют через открытые стандартные протоколы, которая открыта для расширения и взаимодействия с другими системами, причём обеспечивается максимально простой перенос приложений, созданных должным образом, на широкий диапазон аппаратно-программных платформ и пользователю легко переходить от одной платформы к другой; замена или добавление модулей не должны приводить к переобучению пользователей, но должны позволить получить новые возможности

Итак, для того чтобы информационную систему можно было отнести к открытым системам, она должна обладать совокупностью вышеназванных свойств. Раскроем их ещё раз, но другими словами и чуть поподробнее:
	• взаимодействие/интероперабельность – способность к взаимодействию с другими прикладными системами на локальных и (или) удаленных платформах (технические средства, на которых реализована информационная система, объединяются сетью или сетями различного уровня);
	 • стандартизуемость – программные и информационные системы проектируются и разрабатываются на основе согласованных международных стандартов и предложений, реализация открытости осуществляется на базе множества согласованных стандартов (профилей) в области информационных технологий; 
	 • расширяемость/масштабируемость – возможность добавления новых функций информационной системы или изменения некоторых уже имеющихся 7 при неизменных остальных функциональных частях системы, возможность перемещения прикладных программ и передачи данных в системах и средах, которые обладают различными характеристиками производительности и различными функциональными возможностями; 
	 • мобильность/переносимость – обеспечение возможности переноса прикладных программ и данных при модернизации или замене аппаратных платформ информационных систем (ИС) и возможности работы с ними специалистов без специальной переподготовки при изменениях ИС;
	  • дружественность к пользователю – развитые унифицированные интерфейсы в процессах взаимодействия в системе «пользователь – компьютерное устройство – программное обеспечение», позволяющие работать пользователю, не имеющему специальной системной подготовки. Пользователь должен работать с бизнес-задачами, а не с проблемами компьютера и программного обеспечения.
2. ==Что такое итология? Что она изучает?==
**Итология** — это научная дисциплина, которая изучает особенности развития, функционирования и взаимодействия **информационных технологий** (ИТ) в разных сферах жизни общества.

Она фокусируется на:

1. **Теории и практике информационных технологий.**  
    Изучает, как создаются, работают и совершенствуются информационные системы.
2. **Влиянии ИТ на общество.**  
    Анализирует, как технологии меняют социальные, экономические и культурные процессы.
3. **Этических и правовых аспектах.**  
    Разбирает вопросы, связанные с безопасностью данных, конфиденциальностью и ответственностью разработчиков.
4. **Будущих тенденциях.**  
    Прогнозирует, как ИТ будут развиваться в долгосрочной перспективе.
Таким образом, итология рассматривает ИТ не только с технической стороны, но и с точки зрения их влияния на мир в целом.

3. ==Эволюция открытых систем==
История концепции открытых информационных систем началась в конце 1960-х – начале 1970-х годов, когда появилась необходимость обеспечения переносимости программ и данных между поколениями компьютеров. Переход на новые, более мощные системы требовал сохранения ранее созданного программного обеспечения, так как его разработка занимала значительные ресурсы. Одним из первых шагов в этом направлении стало создание компьютеров серии IBM-360. Эти машины обладали единой архитектурой и при использовании одной операционной системы позволяли без проблем исполнять уже готовые двоичные программы на разных версиях компьютеров одной серии. Существенную роль в этом процессе играли механизмы виртуальной памяти, которые позволяли сохранять совместимость при смене аппаратного обеспечения.

Введение стандартов на языки программирования высокого уровня, такие как ФОРТРАН и КОБОЛ, стало следующим шагом в развитии переносимости. Эти стандарты, позже доработанные и расширенные, обеспечили создание переносимых программ. Национальные и международные организации начали сопровождать развитие языков, что превратило их в стандарты де-факто. (Просто упомянуть про эти языки, так-то вода)

Ключевую роль в развитии открытых систем сыграли компьютеры VAX компании Digital Equipment Corp., работающие под ОС VMS (Virtual Memory System).  Каждый компьютер этой линии, вне зависимости от размера, мог исполнять один и тот же набор приложений. В 1970-80-х годах они стали стандартом для автоматизированного проектирования, управления базами данных и машинной графики. Одновременно с этим происходило развитие сетевых технологий, включая DECnet и TCP/IP, что способствовало интеграции различных систем.

С появлением персональных компьютеров и ОС MS-DOS стандарты среды стали определяющим фактором. Однако системы MS-DOS, ограниченные 16-разрядной архитектурой и минимальной защитой, постепенно уступили место более универсальным и переносимым UNIX-системам. UNIX оказалась наилучшей базой для построения открытых систем благодаря машинной независимости, поддержке высокоуровневых языков и доступу к исходным кодам. 

Важным этапом стало принятие стандартов POSIX, обеспечивающих унификацию интерфейсов для приложений. Благодаря этому приложения для UNIX-систем стали легко переносимыми как между UNIX-системами, так и на другие платформы, поддерживающие эти стандарты. TCP/IP стек, активно использовавшийся в сетях, способствовал объединению различных систем, что стало основой для концепции открытых систем.

С развитием международных стандартов и сетевых технологий к концу ХХ века возникли модели открытых систем, включая GNU/Linux. Эти системы обеспечивали доступ к исходному коду, возможность изучения и модификации программ, что отличало их от проприетарных решений.

Сегодня открытые системы лежат в основе создания информационной инфраструктуры. Они обеспечивают переносимость программ, интеграцию разнородных систем и защиту информации. Важной задачей стало формирование законодательной и нормативной базы, способствующей внедрению открытых систем и информационной безопасности. Государственная политика направлена на развитие и использование международных стандартов с адаптацией к отечественным условиям.

Таким образом, ретроспектива открытых систем демонстрирует их ключевую роль в переходе к информационному обществу. Эти технологии стали основой для создания универсальных, интегрированных и безопасных информационных систем.

4. ==Достоинства открытых информационных технологий==
Основные преимущества открытых систем связаны с их гибкостью и удобством. Вот их основные выгоды, изложенные простым языком:

- **Меньше затрат на разработку**: На рынке уже есть много готовых компонентов, которые можно использовать, вместо того чтобы создавать всё с нуля.
- **Легкая модернизация**: Систему можно легко адаптировать к новым задачам, добавляя или меняя модули благодаря её гибкой и модульной структуре.
- **Простая интеграция**: Открытые стандарты делают объединение разных систем быстрым и лёгким.
- **Экономия денег**: Компоненты стоят дешевле, а конкуренция между производителями снижает цены. Можно часто обновлять систему без больших затрат.
- **Надежность**: Выбирая из множества доступных модулей, можно найти те, которые работают наиболее стабильно.
- **Меньше простоев**: Если что-то ломается, всегда можно быстро найти замену, так как доступно множество совместимых модулей.
- **Простота установки и использования**: Открытые системы легко запускать в работу, без необходимости долго обучать сотрудников или привлекать специалистов.
- **Меньше обучения персонала**: Обслуживание таких систем не требует сложного обучения, что упрощает их использование.
- **Доступ к новейшим технологиям**: Производители предлагают самые современные решения, из которых можно выбрать лучшее.
- **Долговечность системы**: Когда оборудование устаревает, его легко заменить или добавить новые функции, что увеличивает срок службы всей системы.

В целом, открытые системы удобны, экономичны и легко адаптируются к изменениям.
Недостатки:

- Сложности в управлении системами, созданными из множества компонентов от разных производителей.
- Возможные проблемы с безопасностью, так как открытые коды доступны для анализа.
5. ==GPT- и MBR- спецификации распределения дискового пространства.==
GPT и MBR — это два разных способа (или спецификации) разбиения жесткого диска или SSD на отдельные разделы, чтобы компьютер знал, как использовать это пространство для хранения данных. Вот простое объяснение:

---

### **MBR (Master Boot Record)**

Это более старый способ, существующий с начала 1980-х годов.

- **Особенности:**
    1. **Поддержка до 4 разделов**: MBR позволяет создать максимум 4 основных раздела. Если нужно больше, придётся использовать один из них как расширенный раздел и внутри него создавать дополнительные логические разделы.
    2. **Ограничение по размеру**: Максимальный размер диска, который поддерживает MBR, — 2 ТБ.
    3. **Главная запись загрузки**: В начале диска хранится специальный сектор — **загрузочная запись**, содержащая таблицу разделов и код для загрузки операционной системы.
    4. **Уязвимость**: Если загрузочная запись повреждается, доступ ко всему диску может быть утерян.

**Пример**: MBR — это как старый блокнот, где ограничено количество записей (разделов), а информация записана в одном месте (загрузочной записи).

Таблица разделов — это специальная структура данных на жестком диске или SSD, которая описывает, как разделено его пространство. Она указывает, где начинаются и заканчиваются разделы (части диска), и какую функцию они выполняют. (MBR и GPT - это типы таблиц разделов).

**BIOS** и **UEFI** — это технологии, которые управляют начальной загрузкой компьютера. Они играют важную роль в инициализации оборудования и загрузке операционной системы. Вот простое объяснение:

---

### **1. BIOS (Basic Input/Output System)**

- **Что это?**  
    BIOS — это старая система начальной загрузки, разработанная ещё в 1980-х.
    
- **Как работает?**
    
    - Находится в специальной микросхеме на материнской плате.
    - При включении компьютера проверяет подключённое оборудование (жесткий диск, процессор, оперативную память).
    - Передаёт управление загрузчику операционной системы, который находится на диске.
- **Связь с MBR:**
    
    - BIOS работает только с дисками, использующими таблицу разделов **MBR**.
    - Это ограничивает размер поддерживаемого диска (до 2 ТБ).
- **Недостатки:**
    
    - Устаревший интерфейс.
    - Ограниченная функциональность.
    - Медленная загрузка.

---

### **2. UEFI (Unified Extensible Firmware Interface)**

- **Что это?**  
    UEFI — это современная замена BIOS, разработанная для работы с новыми устройствами и технологиями.
    
- **Как работает?**
    
    - Также хранится в микросхеме на материнской плате, но значительно мощнее.
    - Поддерживает графический интерфейс и управление мышью.
    - Быстрее инициализирует оборудование и загружает операционную систему.
- **Связь с GPT:**
    
    - UEFI поддерживает диски с таблицей разделов **GPT**.
    - Это позволяет работать с большими дисками (объемом более 2 ТБ).
    - Обеспечивает надёжность за счёт дублирования информации о разделах.
- **Преимущества:**
    
    - Совместимость с современным оборудованием.
    - Поддержка функции Secure Boot (защита от вредоносных программ).
    - Гибкость и масштабируемость.


### **GPT (GUID Partition Table)**

Это современный стандарт, созданный для замены MBR.

- **Особенности:**
    1. **Много разделов**: GPT поддерживает до 128 разделов на одном диске (в зависимости от ОС).
    2. **Нет ограничения по размеру диска**: GPT работает с дисками объёмом больше 2 ТБ, что важно для современных накопителей.
    3. **Повышенная надёжность**: Информация о разделах хранится в нескольких местах на диске, что позволяет восстановить данные, если одна из записей будет повреждена.
    4. **Совместимость с UEFI**: GPT используется с UEFI (современной заменой BIOS), что делает его предпочтительным для новых систем.

**Пример**: GPT — это как электронная таблица (Excel), где можно создать много строк (разделов), и информация автоматически дублируется для надёжности.

---

### **Ключевые отличия:**

|Характеристика|**MBR**|**GPT**|
|---|---|---|
|Максимальный размер диска|До 2 ТБ|Больше 2 ТБ (петабайты)|
|Максимальное количество разделов|4 основных (или логические)|До 128|
|Надёжность|Уязвимость к повреждению|Информация дублируется|
|Совместимость|Работает с BIOS|Работает с UEFI и некоторыми BIOS|
|Современность|Старый стандарт|Новый стандарт|

---

### **Когда использовать:**

- **MBR**: Если у вас старый компьютер или диск меньше 2 ТБ.
- **GPT**: Если у вас новый компьютер с UEFI или диск объёмом больше 2 ТБ.

GPT постепенно вытесняет MBR, потому что он более надёжен, удобен и подходит для современных устройств.
6. ==Эталонная модель открытых систем (OSE/RF).==
### **Что такое эталонная модель OSE/RM?**

Это концепция, которая помогает организовать работу информационных систем так, чтобы разные их компоненты могли взаимодействовать друг с другом, быть удобными для переноса (например, с одной платформы на другую) и использования в разных средах.

---

### **Главные идеи:**

1. **Информационная система как "чёрный ящик"**
    
    - Система рассматривается как нечто целое, с чем взаимодействуют через специальные "границы" — интерфейсы.
    - Важно, чтобы эти интерфейсы были стандартизированы, чтобы приложения могли "общаться" с системой или другими приложениями, независимо от того, где они работают.
2. **Центральная часть — прикладная платформа**
    
    - Это набор программного и аппаратного обеспечения, который предоставляет приложениям необходимые ресурсы (например, память, процессор, сетевые возможности).
    - Пример прикладной платформы: компьютер с установленной операционной системой.
3. **Элементы модели**
    
    - **Логические объекты** — это сущности, которые выполняют конкретные функции. Например:
        - Приложения (программы, данные, инструкции).
        - Платформа, на которой работают приложения.
        - Внешняя среда (сети, устройства, другие платформы).
    - **Интерфейсы** — точки взаимодействия:
        - **API (Application Program Interface):** как приложение общается с платформой.
        - **EEI (External Environment Interface):** как платформа общается с внешними системами (например, с другими компьютерами или сетями).
4. **Две группы стандартов:**
    
    - **Стандарты API:** чтобы приложения могли быть перенесены с одной системы на другую без серьёзных изменений.
    - **Стандарты EEI:** чтобы платформа могла взаимодействовать с внешними системами.

---

### **Как это всё работает?**

- Приложение работает на платформе, которая предоставляет ему нужные ресурсы. Например:
    - Программа использует процессор, чтобы выполнять вычисления.
    - Программа сохраняет данные на диск с помощью файловой системы.
- Чтобы приложение могло без проблем запускаться на разных платформах, используют стандарты API. Это снижает необходимость дорабатывать приложение при переносе.
- Чтобы платформа могла взаимодействовать с другими системами, используют стандарты EEI.

---

### **Категории сервисов (услуг), которые предоставляет модель:**

1. **Системные сервисы:** ресурсы операционной системы, такие как управление файлами или памятью.
2. **Коммуникационные сервисы:** работа с сетями, передача данных.
3. **Информационные сервисы:** доступ и управление данными (например, базы данных).
4. **Сервисы взаимодействия с человеком:** интерфейсы, с которыми работает пользователь (графические интерфейсы, команды).

---

### **Как переносимость достигается?**

- Программы делятся на две части:
    - **Неизменяемая часть:** работает на любой платформе.
    - **Изменяемая часть:** может потребовать доработки при переносе, но её стараются минимизировать.
- Все функции приложения выполняются через стандартизированный интерфейс API, что позволяет избежать привязки к конкретной платформе.

---

### **Пример из реальной жизни:**

- Представьте, что вы разработали текстовый редактор. Если вы следуете стандартам OSE, ваш редактор:
    - Сможет работать на Windows, Linux и macOS без значительных изменений.
    - Будет передавать данные другим приложениям (например, в PDF-генератор), даже если эти программы находятся на другой платформе.

---

### **Ключевая идея:**

OSE/RM делает системы универсальными, позволяя легко взаимодействовать приложениям, платформам и внешним устройствам. Это снижает зависимость от конкретных производителей и делает системы более гибкими и удобными.

7. ==Модель взаимодействия открытых систем (OSI)==
Модель взаимодействия открытых систем (OSI/RM) — это концепция, которая описывает, как данные передаются по сети от одного компьютера к другому. Она делит этот процесс на 7 уровней, каждый из которых выполняет свою задачу. Эта модель была создана для стандартизации сетей и упрощения взаимодействия между системами разных производителей.

Вот что это значит простыми словами:

---

### **Зачем нужна модель OSI?**

Раньше разные производители создавали свои технологии, и они не всегда могли работать вместе. Например, программа от одного разработчика не могла передавать данные через сеть устройства другого производителя. OSI помогает решить эту проблему, стандартизируя способы передачи данных и взаимодействия приложений.

---

### **7 уровней OSI и их задачи:**

1. **Физический уровень (Physical Layer):**
    
    - **Что делает?** Передаёт биты (0 и 1) через физическую среду, такую как кабели, волокна или радиосигналы.
    - **Пример:** Как подключить кабель Ethernet и какой сигнал по нему передаётся.
2. **Канальный уровень (Data Link Layer):**
    
    - **Что делает?** Разбивает данные на небольшие блоки (кадры) и отправляет их через физический уровень. Следит за тем, чтобы кадры доходили до следующего устройства.
    - **Пример:** Ваш компьютер отправляет данные по Wi-Fi с помощью MAC-адресов.
3. **Сетевой уровень (Network Layer):**
    
    - **Что делает?** Определяет маршруты, по которым данные проходят от отправителя к получателю, даже если между ними находятся другие сети. Использует IP-адреса.
    - **Пример:** Когда вы заходите на сайт, ваш запрос проходит через множество маршрутизаторов.
4. **Транспортный уровень (Transport Layer):**
    
    - **Что делает?** Делит данные на сегменты, обеспечивает их доставку в правильном порядке и проверяет на ошибки.
    - **Пример:** Протокол TCP гарантирует, что все части видео, которое вы смотрите, дойдут в нужной последовательности. (есть еще протокол UDP)
5. **Сеансовый уровень (Session Layer):**
    
    - **Что делает?** Управляет началом, поддержанием и завершением связи между приложениями.
    - **Пример:** Когда вы разговариваете по видеозвонку, этот уровень следит, чтобы соединение оставалось стабильным.
6. **Уровень представления (Presentation Layer):**
    
    - **Что делает?** Преобразует данные в формат, понятный приложениям, и занимается шифрованием.
    - **Пример:** Кодирование видео в MP4, чтобы ваш плеер мог его воспроизвести.
7. **Прикладной уровень (Application Layer):**
    
    - **Что делает?** Предоставляет интерфейсы между пользователями и сетью через приложения.
    - **Пример:** Браузер использует HTTP для загрузки веб-страниц.

---

### **Горизонтальная и вертикальная модели:**

- **Горизонтальная модель:**  
    Это взаимодействие между двумя устройствами через один и тот же уровень. Например, два компьютера обмениваются данными через сетевой уровень с использованием IP.
    
- **Вертикальная модель:**  
    Это взаимодействие между уровнями одной системы. Например, браузер на прикладном уровне отправляет запрос через транспортный уровень.
    

---

### **Почему TCP/IP вытеснил OSI?**

- TCP/IP проще в использовании и быстрее внедрялся на практике.
- Он создавался для реальных задач (сети ARPANet), а OSI разрабатывалась как теоретическая модель.
- TCP/IP стал основой Интернета, и разработчики начали ориентироваться на него.

---

### **Пример использования OSI:**

Допустим, вы отправляете электронное письмо:

1. **Прикладной уровень:** Почтовая программа формирует письмо.
2. **Уровень представления:** Письмо кодируется в понятный системе формат.
3. **Сеансовый уровень:** Устанавливается соединение с сервером.
4. **Транспортный уровень:** Письмо разбивается на сегменты для передачи.
5. **Сетевой уровень:** Определяется маршрут для доставки письма.
6. **Канальный уровень:** Сегменты превращаются в кадры для отправки по Wi-Fi или Ethernet.
7. **Физический уровень:** Кадры передаются как сигналы по кабелю или через радиоволны.

В итоге получатель получает ваше письмо в обратном порядке.

**Коммутаторы (Switches)** и **маршрутизаторы (Routers)** — это устройства, которые играют важную роль в организации и управлении сетями, но их функции различаются.

### **Коммутаторы (Switches):**

1. **Что это?** Коммутатор — это сетевое устройство, которое соединяет несколько устройств внутри локальной сети (LAN), таких как компьютеры, принтеры, серверы и т.д. Он работает на **канальном уровне (Data Link Layer)** модели OSI.
    
2. **Как работает?** Коммутатор принимает данные от одного устройства и направляет их только к тому устройству, для которого эти данные предназначены. Он использует **MAC-адреса** для определения, куда отправить данные.
    
3. **Пример:** Если у вас в офисе несколько компьютеров, подключённых к сети, и один из них отправляет файл, коммутатор будет направлять этот файл только на нужный компьютер, а не на все устройства в сети.
    
4. **Задача:**
    
    - Обеспечивает **локальную связь** между устройствами внутри одной сети.
    - Повышает эффективность и безопасность, так как данные не рассылаются по всей сети, а направляются только к получателю.

---

### **Маршрутизаторы (Routers):**

1. **Что это?** Маршрутизатор — это устройство, которое соединяет разные сети между собой, например, домашнюю сеть с интернетом или несколько офисных сетей. Он работает на **сетевом уровне (Network Layer)** модели OSI.
    
2. **Как работает?** Маршрутизатор анализирует IP-адреса и решает, как передавать данные между различными сетями. Он выбирает лучший путь для передачи данных через маршруты, используя таблицы маршрутизации.
    
3. **Пример:** Если вы хотите выйти в интернет, данные из вашей локальной сети передаются через маршрутизатор в глобальную сеть (например, через модем или провайдера). Маршрутизатор направит запрос в нужную сторону, чтобы получить данные с веб-сайта.
    
4. **Задача:**
    
    - Соединяет **разные сети** (например, локальную сеть с интернетом).
    - Определяет **маршрут** для передачи данных между сетями, обеспечивая **глобальное взаимодействие**.

---

### **Основные различия:**

- **Коммутатор** работает внутри одной сети, связывая устройства на канальном уровне (с помощью MAC-адресов).
- **Маршрутизатор** работает между разными сетями, направляя пакеты данных на основе их IP-адресов.

### **Пример ситуации:**

- Если у вас есть несколько компьютеров в офисе, они могут общаться между собой через коммутатор.
- Если вы хотите подключиться к интернету, данные должны пройти через маршрутизатор, который передаст их в глобальную сеть.

8. ==Стандарты, открытые стандарты. Понятие профиля.==
### Стандарт

Стандарт — это документ, который описывает, как должен выглядеть или работать какой-то объект или процесс. Он может содержать инструкции или требования, которые нужно выполнить, чтобы что-то было сделано правильно. Например, стандарт может описывать, как должен быть устроен электронный прибор, чтобы он правильно работал, или как должна быть организована работа на предприятии.

### Открытый стандарт

Открытый стандарт — это такой стандарт, который доступен всем и не является секретом. Он не принадлежит какой-то одной компании или организации, а используется всеми, кто хочет его применять. Например, если компания создала технологию и сделала её открытым стандартом, другие компании могут использовать её в своих продуктах, не платя за лицензии или не нарушая патенты.

### Профиль

Профиль — это набор нескольких стандартов, которые вместе позволяют выполнить какую-то задачу. Например, для того чтобы компьютер мог подключиться к интернету, нужно использовать несколько стандартов: для передачи данных, для безопасности и для взаимодействия с другими устройствами. Все эти стандарты вместе могут составлять профиль для подключения к интернету.

9. ==Правовые аспекты информатики. Открытые и проприетарные информационные технологии.==
Правовые аспекты информатики связаны с правилами и законами, которые регулируют использование информационных технологий. Это касается вопросов авторского права, лицензирования программ и защиты информации.

### Открытые информационные технологии

Открытые технологии создаются так, чтобы их можно было свободно использовать, изменять и распространять. Главные черты:

- **Открытые стандарты**: их можно применять без необходимости платить или получать специальное разрешение.
- **Гибкость и совместимость**: разные программы и устройства могут работать вместе.
- **Исходный код доступен**: это позволяет исправлять ошибки, добавлять новые функции и настраивать систему под свои задачи.

### Проприетарные информационные технологии

Проприетарные (или закрытые) технологии защищены законом, и их использование строго контролируется. Особенности:

- **Нет доступа к внутреннему устройству программы (исходному коду)**: вы не можете вносить изменения.
- **Лицензия**: вы можете использовать программу только на условиях, указанных разработчиком (например, ограничение на количество пользователей или установок).
- **Защита разработчиков**: компании сохраняют свои эксклюзивные права на продукт.

### Лицензии

Лицензия — это официальное разрешение на использование программы.

- **Свободные лицензии** (например, GNU GPL): дают пользователям много прав, включая возможность изменения и распространения.
- **Проприетарные лицензии** (например, EULA): дают минимальные права, только на использование в рамках условий.

### Главное отличие

Открытые технологии помогают всем развивать и улучшать решения, делая их доступными для большого числа пользователей. Проприетарные технологии, наоборот, позволяют компаниям сохранять контроль над своими продуктами и поддерживать конкурентное преимущество.

10. ==Фонд свободного программного обеспечения. Манифест GNU.==
В 1984 году Ричард Столлман основал Фонд свободного программного обеспечения (Free Software Foundation, FSF), чтобы продвигать идеи свободного ПО. До этого многие компании делали программы закрытыми: скрывали их внутреннее устройство (исходный код), запрещали копировать и изменять. Столлман считал, что такие ограничения мешают прогрессу, потому что программисты не могли использовать уже существующие решения и вынуждены были писать всё с нуля.

### Проект GNU

Столлман решил создать полностью свободную операционную систему, похожую на UNIX, но без ограничений. Проект получил название **GNU**, что расшифровывается как "GNU Not Unix" (GNU — это не UNIX). В 1985 году он написал **Манифест GNU**, в котором объяснил свою цель: сделать программное обеспечение доступным для всех, чтобы его можно было использовать, изучать, изменять и распространять.

### Четыре свободы пользователя

Основные права, которые должны быть у каждого, по мнению Столлмана:

1. **Свобода запускать программу** для любых целей.
2. **Свобода изучать, как она работает**, и изменять её под свои нужды (для этого нужен доступ к исходному коду).
3. **Свобода делиться программой** с другими.
4. **Свобода улучшать программу** и делать улучшения доступными для всех.

### GNU General Public License (GPL)

Столлман создал специальную лицензию — **GPL**, которая защищает свободное ПО. Если программа выпущена под этой лицензией:

- Её исходный код должен быть доступен.
- Любой, кто изменит или перераспространит её, обязан сохранить эти свободы для других пользователей.

### Связь с Linux

Проект GNU создал много компонентов для операционной системы, но не закончил разработку её ядра (основной части системы). Позже Линус Торвальдс разработал ядро Linux, которое отлично подошло для использования с инструментами GNU. В результате появилась система, которую часто называют **GNU/Linux**, потому что она объединяет разработки обеих команд.

**Итог:** Идеи Столлмана заложили основу для создания большого сообщества разработчиков свободного ПО, благодаря чему появились такие проекты, как Linux, и многие другие.

11. ==Понятия CopyRight и CopyLeft. Лицензирование программного обеспечения.==
**Copyright и Copyleft** — это два подхода к защите прав на интеллектуальную собственность, например, программное обеспечение.

---

### **Что такое Copyright (авторское право)?**

- **Copyright** защищает права автора на произведение: например, книгу, музыку или программу.
- Автор может контролировать, кто и как использует его работу: копирует, изменяет или продаёт.
- По умолчанию никто не может использовать произведение без разрешения автора.
- Пример: Если программа защищена Copyright, вы можете её использовать только на условиях, которые указаны в лицензионном соглашении. Например, нельзя изменять программу или передавать её другим людям без разрешения.

---

### **Что такое Copyleft?**

- **Copyleft** работает наоборот: автор даёт всем свободу использовать, изменять и распространять своё произведение.
- Но есть одно условие: все модификации или производные работы также должны оставаться свободными.
- Это гарантирует, что никто не сможет сделать программу закрытой.
- Пример: Лицензия GNU GPL (созданная Ричардом Столлманом) позволяет свободно использовать и изменять программу, но требует, чтобы все её улучшенные версии также были доступны всем.

---

### **Лицензии программного обеспечения**

- **Лицензия** — это документ, который разрешает использовать программное обеспечение на определённых условиях.
- Лицензия не даёт вам программу «в собственность», а только разрешение на использование.

#### Типы лицензий:

1. **Проприетарные лицензии**:
    - Программы с закрытым исходным кодом.
    - Пользователь может только использовать программу, но не может изменять её или изучать, как она работает.
    - Пример: Microsoft Windows.
2. **Свободные лицензии**:
    - Программы с открытым исходным кодом.
    - Пользователь может изменять, копировать и распространять программу.
    - Пример: Linux с лицензией GNU GPL.

---

### **Как лицензии работают?**

- Лицензии обычно прописывают:
    - Сколько копий программы можно установить.
    - Можно ли передавать программу другим людям.
    - Какие гарантии предоставляет разработчик (обычно никаких).

---

### **Специальные лицензии:**

1. **Корпоративные лицензии**:
    - Для компаний, которые покупают программное обеспечение для большого количества сотрудников.
    - Предлагают скидки и специальные условия.
2. **Лицензии для студентов**:
    - Удешевлённые версии программ для учебных заведений или личного обучения.

---

**В чём разница между Copyright и Copyleft?**

- Copyright защищает права автора и ограничивает права пользователей.
- Copyleft защищает права пользователей, но требует, чтобы свобода использования сохранялась для всех.

12. ==General Public License (GPL): структура, основные положения, версии.==
### GNU General Public License (GPL): основные положения и версии

**GNU GPL** — это лицензия на свободное программное обеспечение, которая позволяет пользователям свободно использовать, изменять и распространять программы. Она была создана в рамках проекта GNU в 1988 году.

---

### **Основные свободы GPL**

1. **Свобода использования**: вы можете запускать программу для любых целей.
2. **Свобода изучения**: вы можете понять, как работает программа, и менять её. Для этого вам предоставляют доступ к исходному коду.
3. **Свобода копирования**: вы можете делать копии программы и делиться ими с другими.
4. **Свобода улучшения**: вы можете улучшать программу и распространять свои изменения, но тоже на условиях GPL.

---

### **Как работает GPL?**

- Если вы берёте программу, лицензированную по GPL, и изменяете её, то обязаны также распространять исходный код вашей версии. Это обеспечивает принцип **Copyleft** — никто не может сделать программу закрытой.
- Автор не теряет права на своё произведение, но предоставляет всем пользователям вышеуказанные свободы.

---

### **Версии GPL**

1. **GPL v1 (1989)**:
    
    - Первая версия.
    - Гарантировала доступ к исходному коду и запрещала закрывать программы, сделанные на основе открытого кода.
2. **GPL v2 (1991)**:
    
    - Уточнила, что все изменения и их исходные коды должны распространяться под той же лицензией.
    - Не охватывала программы, работающие как интернет-сервисы (например, веб-приложения).
3. **GPL v3 (2007)**:
    
    - Добавлены пункты, касающиеся использования программ в интернете (разделение "распространение" и "личное использование").
    - Включены правила о патентах: связанные патенты передаются с программой для свободного использования.
    - Запрещено использование DRM (Digital Restriction Management), системы, ограничивающей доступ к информации.

---

### **LGPL (Lesser GPL)**

- Это облегчённая версия GPL, чаще используется для библиотек программного обеспечения.
- Позволяет использовать библиотеки в проприетарных программах (например, для разработки платного ПО).
- Разработчик библиотеки может перевести её на обычную GPL, но обратно это сделать нельзя.

---

### **Пример использования GPL**

Многие известные проекты, такие как Linux, распространяются по лицензии GPL, а **OpenOffice.org** использует LGPL, что позволяет использовать его компоненты в других проектах, включая коммерческие.

GPL защищает свободу пользователей, а LGPL даёт больше гибкости для разработчиков, которые работают с открытыми библиотеками.

13. ==Лицензии общественного достояния. Public Domain Software. CopyLefted Software.==
### Общественное достояние и лицензии на программы

**Общественное достояние** — это когда произведение (текст, музыка, программа и т. д.) может использоваться абсолютно свободно. Никто не владеет этим произведением, и на него не распространяются авторские права.

---

### **Что это значит?**

- Произведение можно копировать, изменять, распространять или даже продавать, и для этого не нужно спрашивать разрешения или указывать автора.
- Это самая «открытая» форма контента, потому что нет никаких ограничений.

---

### **Как работает общественное достояние в разных странах?**

- Законы об авторском праве отличаются в разных странах. Например, в одной стране произведение может быть в общественном достоянии, а в другой — всё ещё защищено законом.
- Обычно произведение переходит в общественное достояние после истечения срока действия авторских прав, но этот срок зависит от конкретной страны.

---

### **Программное обеспечение в общественном достоянии**

- Это программы, которые не защищены авторским правом, патентами или товарными знаками.
- Вы можете делать с ними всё, что захотите: изменять, продавать, использовать в своих проектах и даже не указывать автора.

---

### **Как программы попадают в общественное достояние?**

- По законам (например, Бернская конвенция), любое созданное произведение автоматически получает авторское право. Даже программы.
- Если автор хочет передать свою программу в общественное достояние, он должен **официально отказаться от своих прав**. Например, с помощью документа, в котором говорится, что он отказывается от авторских прав.

14. ==Проекты FOSS (Free and Open Source Software)==
### Что такое FOSS?

**FOSS** (Free and Open Source Software) — это программы, которые можно использовать, изменять и распространять свободно и без ограничений. Такие проекты создаются с идеей, что программное обеспечение должно быть доступно для всех, а его код — открыт для изучения и улучшения. Упор делается именно на свободу по, а не его бесплатность.

---

### Основные принципы FOSS:

1. **Свободный доступ к коду**:  
    Вы можете посмотреть, как программа устроена, изменить её под свои нужды или исправить ошибки.
    
2. **Коллективная разработка**:  
    Над проектами работают как профессиональные разработчики, так и обычные пользователи со всего мира. Это командная работа.
    
3. **Открытая модель разработки**:  
    Все изменения и новые версии выкладываются в общий доступ. Обычно обновления выпускаются часто, чтобы процесс был прозрачным.
    

---

### Чем FOSS отличается от других программ?

- **Свободный** не значит только "бесплатный". Это больше про свободу делать с программой всё, что хотите (в рамках лицензии).
- Пример: программы с открытым исходным кодом на платформе GitHub.

---

### Примеры FOSS:

- **Linux** (операционная система)
- **Firefox** (веб-браузер)
- **LibreOffice** (альтернатива Microsoft Office)
- **GIMP** (редактор изображений)

FOSS — это не просто программы, а целое движение, которое помогает создавать лучшее программное обеспечение для всех!

15. ==Интернет как пример открытых систем и информационных технологий.==
### Интернет как пример открытой системы

Интернет — отличный пример открытой системы, где разные устройства и программы работают вместе благодаря общим правилам и стандартам.

---

### Почему Интернет открыт:

1. **Единые стандарты**:  
    Интернет работает благодаря наборам правил (протоколам), таким как TCP/IP, HTTP (для веб-страниц) или SMTP (для почты). Эти правила делают возможным взаимодействие любых устройств — компьютеров, телефонов, серверов — независимо от их производителя.
    
2. **Подходит для любых платформ**:  
    Любое устройство, которое поддерживает интернет-протоколы, может подключаться и взаимодействовать. Например, компьютер на Windows легко общается с сервером на Linux.
    
3. **Совместная работа устройств**:  
    Интернет создаёт единую сеть, где устройства из разных стран и с разными системами могут «понимать» друг друга.
    
4. **Открытый код**:  
    Многие технологии, поддерживающие Интернет (например, серверы Apache или операционная система Linux), имеют открытый исходный код. Это значит, что любой человек может изучить, улучшить или адаптировать их.
    

---

### Основные свойства Интернета как открытой системы:

- **Глобальная доступность**: Интернет работает по всему миру и доступен для всех.
- **Масштабируемость**: К Интернету можно подключать новые устройства, не ломая его архитектуру.
- **Гибкость**: Интернет легко адаптируется под новые технологии и протоколы.
- **Поддержка инноваций**: Благодаря открытым стандартам люди могут придумывать и внедрять новые интернет-сервисы, например, соцсети или облачные хранилища.

---

### Почему это важно?

Интернет — это не просто сеть, а платформа для общения, работы и инноваций. Его открытая природа помогает людям по всему миру соединяться и развивать технологии.

16. ==Линус Торвальдс и GNU/Linux==
### Линус Торвальдс и GNU/Linux: история создания

В 1991 году финский студент Линус Торвальдс решил написать ядро операционной системы, совместимой с Unix, для своего компьютера. Примером для него стала Minix — простая операционная система, которая умещалась на дискете и работала на тогдашних ПК.

---

### Как появился Linux:

1. **Зачем это было нужно?**  
    Линус хотел запустить простую командную оболочку поверх своей системы. Он начал писать код на языках C и Ассемблер, создавая первые версии ядра. Это стало основой Linux — простой и легкой Unix-подобной системы.
    
2. **Почему Linux?**  
    Первоначально Линус хотел назвать свою систему **Freax**, но человек, который выкладывал её в интернет (Ари Лемке), создал каталог с названием **Linux**. Так название и закрепилось.
    
3. **Свободное ПО**  
    Линус опубликовал Linux под лицензией GPL, чтобы каждый мог свободно использовать, изучать и изменять его.
    

---

### Связь Linux с проектом GNU:

1. **Что такое GNU?**  
    До появления Linux уже существовал проект GNU, созданный Ричардом Столлманом. В рамках этого проекта были созданы программы, необходимые для работы операционной системы: текстовый редактор Emacs, компилятор GCC, отладчик GDB и другие. Однако проекту не хватало ядра (основной части ОС).
    
2. **Проблемы GNU с ядром**  
    Планировалось использовать ядро Hurd, но его разработка сильно затянулась. В это время появилось ядро Linux, которое, хоть и было несовершенным, работало.
    
3. **Объединение GNU и Linux**  
    Комбинировав ядро Linux с программами GNU, разработчики создали полностью рабочую и свободную операционную систему. Сегодня её часто называют Linux, хотя правильнее было бы GNU/Linux.
    

---

### Почему это важно?

- Linux стал основой для множества операционных систем, которые работают на компьютерах, серверах, телефонах и даже в бытовой технике.
- Лицензия GPL гарантировала, что система останется свободной и доступной для всех.

Это пример того, как усилия разных людей и проектов смогли создать нечто, что используется по всему миру.

17. ==Стандарты POSIX.==
### Стандарты POSIX: простыми словами

POSIX (Portable Operating System Interface) — это набор правил и стандартов, которые помогают разработчикам писать программы, работающие на разных операционных системах, совместимых с UNIX.

---

### Почему появились стандарты POSIX?

- В 70-80-х годах UNIX стал очень популярным, и разные люди вносили свои изменения в систему, чтобы адаптировать её под разное оборудование.
- Это привело к появлению множества версий UNIX, которые не всегда были совместимы друг с другом.
- Для решения этой проблемы решили стандартизировать базовые функции, чтобы программы могли одинаково работать на всех версиях UNIX и других совместимых системах.

---

### Что описывают стандарты POSIX?

POSIX — это не один стандарт, а целая группа документов, каждый из которых описывает разные аспекты работы системы:

1. **POSIX.0** — введение, общая информация о стандартах.
2. **POSIX.1** — базовые функции системы, такие как работа с файлами и процессами через язык C.
3. **POSIX.2** — оболочки (например, Bash) и базовые утилиты командной строки.
4. **POSIX.4** — работа с задачами реального времени и потоками (многозадачность).
5. **POSIX.6** — безопасность системы.
6. **POSIX.8** — работа с сетями и абстрактные интерфейсы для взаимодействия с сетевыми приложениями.
7. **POSIX.12** — графический интерфейс пользователя (GUI).

И так далее — всего их около 12, каждый из которых отвечает за конкретную часть системы.

---

### Как это работает?

- Программы, написанные с учётом POSIX, могут одинаково работать на всех системах, которые поддерживают этот стандарт.
- Стандарты строго определяют базовые функции, которые **не должны изменяться**.
- Однако разработчики могут добавлять дополнительные функции, если они не мешают работе стандартных.

Пример: команда `ls` (вывод содержимого папки). POSIX определяет её базовый функционал, но вы можете добавить свои опции, которые будут работать только на вашей системе. Главное, чтобы базовые функции, описанные в POSIX, остались такими же.

---

### Почему это важно?

POSIX помогает создавать программы, которые работают на разных системах, от Linux до macOS. Это делает их универсальными и снижает затраты на разработку.

18. ==Проект FreeBSD.==
### Проект FreeBSD: простыми словами

FreeBSD — это операционная система, которая изначально создавалась как часть UNIX в университете Беркли (отсюда название "BSD"). Её главная особенность — **свободная и простая лицензия BSD**, которая позволяет использовать и изменять код практически без ограничений.

---

### Что такое лицензия BSD?

- Вы можете **делать с программой всё, что угодно**: использовать, изменять, распространять, продавать и даже закрывать код.
- Единственное условие — вы должны упоминать авторов оригинального кода и не утверждать, что вы его написали.
- В отличие от лицензии GPL (которая требует открывать все модификации), лицензия BSD этого **не требует**.

#### Пример:

Apple использовала код FreeBSD и микроядро Mach для создания своей системы macOS, но сделала её закрытой и платной. Лицензия BSD это разрешает.

---

### Чем FreeBSD отличается от Linux?

- **FreeBSD** — это **единая система**, где ядро, драйверы и базовые программы разрабатываются одной командой.
- **Linux** — это только ядро. Остальные программы разрабатываются другими проектами (например, GNU), а дистрибутивы собирают разные команды.

---

### Почему FreeBSD популярна?

- **Стабильность и надёжность:** идеально подходит для серверов и сетей.
- **Лицензия:** позволяет использовать код как в свободных, так и в коммерческих проектах.
- **Эффективность:** предоставляет отличное управление памятью и сетевые возможности.

---

### Где используется FreeBSD?

- В серверах и сетях (интранет и интернет).
- Компании могут брать её код и создавать свои продукты, как это сделала Apple с macOS.

FreeBSD — это пример простой и гибкой системы, которая предлагает стабильность, свободу использования и мощные инструменты для разработчиков.

19. ==“Собор и базар” - сравнительный анализ двух подходов к проектированию программного обеспечения.==
### «Собор и базар»: два подхода к созданию программ

Эрик Рэймонд, программист и писатель, в своей статье «Собор и базар» сравнил два стиля разработки программного обеспечения: **«соборный»** и **«базарный»**. Вот как это выглядит простыми словами.

---

### Соборный стиль

- Разработка ведётся как строительство собора: всё планируется заранее, команды работают изолированно и выпускают продукт только тогда, когда он полностью готов.
- Разработчики обычно — небольшая группа экспертов, которые тщательно продумывают каждую деталь.
- Бета-версии появляются редко, и доступ к коду получают только избранные.

**Пример:** многие коммерческие программы, где всё держится в секрете до выпуска.

---

### Базарный стиль

- Работа идёт как на шумном базаре: много участников, часто выпускаются новые версии, все могут видеть и использовать исходный код.
- Программисты из разных мест и со своими идеями вносят вклад в проект, а пользователи активно помогают находить ошибки.
- Главная особенность — децентрализованность: есть небольшая группа разработчиков, которые пишут и координируют код, а вокруг них большая команда тестировщиков и активных пользователей.

**Пример:** Linux — создаётся сообществом, где каждый может участвовать.

---

### Почему базарный стиль эффективен?

- **Быстрое исправление ошибок:** пользователи сами находят и сообщают о проблемах, а программисты исправляют их.
- **Разные идеи:** разработчики получают свежие взгляды от сообщества, что делает программу лучше.
- **Высокая скорость:** благодаря совместной работе большого количества людей проект развивается быстрее.

Эрик Рэймонд заметил, что такой подход может быть даже эффективнее, чем традиционный соборный метод, где всё держится в секрете.

---

### Итог

Базарный стиль — это про открытость и командную работу, а соборный — про тщательность и контроль. Практика показала, что базарная модель особенно хороша для проектов с открытым исходным кодом: она делает их быстрее, качественнее и ближе к пользователям.

20. ==Основные особенности архитектуры операционных систем UNIX и GNU/Linux.==
### Особенности UNIX и GNU/Linux: простыми словами

Операционные системы UNIX и GNU/Linux имеют несколько ключевых особенностей, которые делают их мощными, удобными и гибкими. Вот основные из них:

---

### 1. **Многопользовательская система**

- Несколько человек могут работать с одной системой одновременно, не мешая друг другу.
- У каждого есть свой логин, настройки и доступ только к своим данным.
- Это безопасно: никто не сможет случайно (или специально) вмешаться в работу другого пользователя.

---

### 2. **Многозадачность**

- Система может одновременно запускать несколько программ.
- Например, вы слушаете музыку, скачиваете файл и работаете в текстовом редакторе — всё это происходит параллельно.
- Для фоновых процессов (например, работы сетевых служб) есть специальные программы-«демоны».

---

### 3. **Модульность**

- UNIX и Linux состоят из отдельных частей: ядро, оболочка, утилиты, службы.
- Если нужно обновить или заменить какой-то компонент, это легко сделать, не затрагивая всю систему.

---

### 4. **Ядро (Kernel)**

- Это "мозг" системы, который управляет железом: процессором, памятью, дисками.
- Ядро отвечает за распределение ресурсов и связь между программами и аппаратным обеспечением.

---

### 5. **Портируемость**

- UNIX и Linux работают на разных компьютерах: от серверов до смартфонов.
- Их код написан на языке программирования C, который легко переносится между устройствами.

---

### 6. **Совместимость со стандартами**

- UNIX и Linux следуют стандартам POSIX, что позволяет запускать программы на разных устройствах без доработки.

---

### 7. **Командная оболочка (Shell)**

- Это инструмент, через который пользователи общаются с системой с помощью команд.
- Популярные оболочки (например, Bash или Zsh) позволяют писать скрипты и автоматизировать задачи.

---

### 8. **Открытость (в GNU/Linux)**

- Исходный код Linux доступен всем.
- Вы можете посмотреть, как всё устроено, изменить код под свои нужды или использовать его для обучения.

---

### 9. **Сетевые возможности**

- Сетевые функции изначально встроены в систему.
- Linux поддерживает все популярные протоколы, обеспечивая работу в интернете и локальных сетях.

---

### 10. **Эффективное использование памяти**

- Linux умеет использовать виртуальную память, что позволяет работать даже при ограниченной физической памяти.
- Кэширование и свопинг делают систему быстрой и отзывчивой.

---

### 11. **Философия UNIX**

- Каждая программа выполняет одну задачу, но делает это максимально хорошо.
- Такие программы легко объединять в цепочки (конвейеры), создавая сложные решения из простых команд.

---

### Итог:

UNIX и GNU/Linux — это многозадачные, многопользовательские системы с гибкой архитектурой. Они открыты, масштабируемы, и позволяют каждому адаптировать их под свои нужды. Linux особенно популярна за свою открытость, а философия UNIX делает её простой и удобной для работы.

21. ==Режимы работы систем UNIX и GNU/Linux. Программа init и уровни инициализации.==
### Режимы работы UNIX и GNU/Linux: простыми словами

Операционные системы UNIX и GNU/Linux работают в разных **режимах**, которые определяют, что будет запущено и как система себя поведёт. Эти режимы называют **уровнями инициализации** (или runlevels) и нумеруются от **0 до 6**.

---

### Основные уровни:

1. **0 — Выключение системы**  
    Этот уровень используется, чтобы полностью остановить работу компьютера.
    
2. **1 — Однопользовательский режим (Single-user)**  
    Только один пользователь (обычно администратор root) может работать в системе.  
    Используется для восстановления или исправления проблем.  
    Сервисы и сеть здесь не запускаются.
    
3. **2 — Многопользовательский режим без сети**  
    Поддерживается работа нескольких пользователей, но сеть не работает.  
    Редко используется в современных системах.
    
4. **3 — Многопользовательский режим с сетью**  
    Основной режим для серверов.  
    Поддерживает работу нескольких пользователей, запускает сеть и нужные сервисы.
    
5. **4 — Зарезервированный уровень**  
    Обычно не используется или настраивается для каких-то специальных целей.
    
6. **5 — Графический режим**  
    Запускается графический интерфейс (например, GNOME, KDE).  
    Это стандартный режим для настольных компьютеров.
    
7. **6 — Перезагрузка**  
    Система завершает работу и сразу перезагружается.
    

---

### Как узнать текущий режим?

- Чтобы узнать, в каком режиме работает система, можно использовать команду:
    
    ```bash
    runlevel
    ```
    

---

### Как изменить режим?

1. В старых системах изменение режима можно было настроить в файле **`/etc/inittab`**.  
    В этом файле указывается режим по умолчанию, например:
    
    ```
    id:5:initdefault
    ```
    
    Здесь система загрузится в графическом режиме (уровень 5).
    
2. В современных системах с **systemd** можно переключать режимы с помощью команды:
    
    ```bash
    systemctl isolate <имя_режима>
    ```
    
    Например:
    
    ```bash
    systemctl isolate graphical.target
    ```
    

---

### Программа **init**

- **init** — это первая программа, которая запускается при включении системы.
- Её задача — запустить остальные процессы, такие как сервисы, оболочка или графический интерфейс.
- У программы **init** всегда PID = 1, потому что она — главный процесс.

---

### Современные подходы

- Сейчас многие системы используют вместо **init** более современные инструменты, такие как **systemd**.
- Хотя реализация отличается, принцип остаётся тот же: система запускается в определённом режиме, который определяет, какие функции и службы включать.

---

### Итог:

Режимы работы помогают системе адаптироваться под разные задачи: от ремонта до работы с сетью или графическим интерфейсом. Программа **init** или её аналоги управляют этим процессом, загружая всё необходимое для работы системы.

22. ==Структура файловой системы UNIX и GNU/Linux. Стандарт иерархии файловой системы (FHS).==
Файловая система UNIX и GNU/Linux устроена как дерево, где всё начинается с корня, обозначенного как `/`. Все файлы и папки находятся внутри этого дерева, организованы по определённым правилам, чтобы было удобно работать.

Стандарт FHS (File Hierarchy Standard) определяет, где и какие файлы должны храниться. Вот основные каталоги и их назначение:

---

### Основные каталоги:

1. **`/` (корень)**  
    Самая вершина файловой системы. Всё начинается отсюда.
    
2. **`/bin`**  
    Хранятся основные команды, нужные всем пользователям, например:
    
    - `ls` (показать список файлов),
    - `cp` (копировать файл).
3. **`/sbin`**  
    Команды для системного администрирования, доступные только суперпользователю (админу).
    
4. **`/boot`**  
    Всё, что нужно для загрузки системы: ядро, загрузчик и другие файлы.
    
5. **`/dev`**  
    "Файлы-устройства", представляющие оборудование компьютера, например, диски или принтеры. Пример:
    
    - `/dev/null` — "чёрная дыра" для ненужных данных.
6. **`/etc`**  
    Конфигурационные файлы системы. Здесь настраиваются программы и службы.
    
7. **`/home`**  
    Домашние папки пользователей, где хранятся их личные файлы. Например, у пользователя `alex` будет каталог `/home/alex`.
    
8. **`/lib`**  
    Библиотеки (как "запчасти") для программ из `/bin` и `/sbin`.
    
9. **`/media`**  
    Точки подключения (монтирования) сменных носителей, например флешек или CD.
    
10. **`/mnt`**  
    Временное место для подключения внешних файловых систем.
    
11. **`/opt`**  
    Дополнительное программное обеспечение, установленное вручную.
    
12. **`/proc`**  
    Виртуальная файловая система, показывающая, как работает ядро и процессы.
    
13. **`/root`**  
    Домашний каталог суперпользователя (админа).
    
14. **`/run`**  
    Информация, актуальная только с момента загрузки системы.
    
15. **`/sys`**  
    Содержит данные о железе (устройствах) и драйверах.
    
16. **`/tmp`**  
    Временные файлы. Очищается при перезагрузке.
    
17. **`/usr`**  
    Большинство пользовательских программ, утилит и библиотек.
    
18. **`/var`**  
    Файлы, которые постоянно изменяются: логи, почта, базы данных.
    

---

### Простыми словами:

Файловая система UNIX/Linux организована так, чтобы всё было на своих местах. Это как хорошо устроенный дом: есть комната для каждого назначения. Например, спальня для отдыха (домашняя папка пользователя), кухня для готовки (каталоги для программ), кладовка для инструментов (системные файлы). Благодаря этой структуре легко находить нужные данные и управлять системой.

23. ==Команды для работы с файлами-каталогами.==

Имена файлов содержатся в специальных файлах-каталогах. 

Каждый каталог — это отдельный файл особого типа (он обозначается символом "d", от англ. "directory"), отличающийся от обычного файла с данными. Другими словами, помимо обычных файлов с данными (их называют регулярными файлами) есть файлы-каталоги. Запись в таком файле привязывает имя файла к его дескриптору — айноду (англ inode - index node). Есть главный каталог, его называют корневым; он обозначается /. За счёт того, что в файле-каталоге могут быть указаны другие файлы-каталоги, файловая система получается иерархической. Итак, каталог - это, по существу, список ссылок на айноды, а значит — на файлы или другие файлы-каталоги. Принято говорить, что каталог содержит в себе файлы или другие каталоги, хотя в действительности он только ссылается на них, физическое размещение данных на диске обычно никак не связано с размещением каталога. 

Всякие команды (тут можно никогда не закончить, добавляйте все):

ls - выводит список файлов в каталоге

cd - перейти из одного каталога в другой  
pwd - показывает путь до каталога, в котором находишься от корневого каталога  
mkdir - создаёт каталог

mv - перемещение или переименование

cp - копирование

rm - удаление

tar - сжать или разжать каталог

grep - рекурсивный поиск файла или каталога с указанной строкой в названии

ls -i filename.txt - просмотреть inode файла

find / -inum 1234567 - найти файл по inode 

df -i - проверить сколько inode в системе занято  
(вывод команды будет ~ таким)

Filesystem     Inodes  IUsed  IFree IUse% Mounted on

/dev/sda1      123456  65432  58024   53% /

24. ==Операция монтирования. Файл /etc/fstab.==
### Что такое монтирование?

**Монтирование** — это процесс, который делает устройство (например, флешку или жёсткий диск) доступным для работы в операционной системе. Чтобы использовать данные на устройстве, его нужно «подключить» к какому-то каталогу в системе. После этого все файлы на устройстве будут видны в этом каталоге.

Пример:  
Если вы хотите получить доступ к файлам на разделе диска `/dev/sda1`, вы можете подключить его к папке `/mnt/data` командой:

```bash
mount /dev/sda1 /mnt/data
```

Теперь всё содержимое этого раздела будет доступно в папке `/mnt/data`.

---

### Как работает файл `/etc/fstab`?

Файл `/etc/fstab` — это место, где указано, какие устройства нужно монтировать автоматически при включении компьютера и как это делать. Вместо того чтобы каждый раз вручную вводить команду `mount`, вы настраиваете это один раз в `/etc/fstab`, и система всё сделает сама.

---

### Как выглядит запись в `/etc/fstab`?

Пример записи:

```
UUID=0a3407de-014b-458b-b5c1-848e92a327a3 / ext4 defaults 0 1
```

Разберём по частям:

1. **UUID=0a3407de-014b-458b-b5c1-848e92a327a3**  
    Это уникальный идентификатор раздела диска. Удобнее использовать UUID, потому что он не меняется, даже если вы подключите диск к другому порту.
    
2. **/**  
    Это каталог, куда будет подключён раздел. Здесь он подключается как корневая файловая система.
    
3. **ext4**  
    Тип файловой системы. Это может быть ext4, swap, fat32 и т.д.
    
4. **defaults**  
    Опции монтирования. Обычно просто пишут `defaults`, чтобы использовать стандартные настройки.
    
5. **0**  
    Нужно ли делать резервную копию утилитой `dump`. Обычно пишут `0` (не нужно).
    
6. **1**  
    Нужно ли проверять файловую систему на ошибки утилитой `fsck`.
    
    - `1` — проверять первым (обычно для корневого раздела).
    - `2` — проверять после корневого.
    - `0` — не проверять.

---

### Как настроить автоматическое монтирование?

1. Найдите UUID устройства командой:
    
    ```bash
    blkid
    ```
    
    Это покажет список всех устройств и их UUID.
    
2. Добавьте запись в файл `/etc/fstab`. Например:
    
    ```
    UUID=your-uuid-here /mnt/data ext4 defaults 0 2
    ```
    
    Это настроит автоматическое монтирование устройства с этим UUID в папку `/mnt/data`.
    

---

### Итог:

Монтирование — это способ подключить устройство, чтобы его файлы стали доступны.  
Файл `/etc/fstab` позволяет настроить автоматическое подключение при включении компьютера, чтобы вы не делали это вручную каждый раз.

25. ==Файлы (типы файлов) в системах UNIX и GNU/Linux.==
### Типы файлов в UNIX и GNU/Linux простыми словами

В системах UNIX и GNU/Linux файлы — это не только документы или программы, но и способ работы с устройствами и процессами. Все делится на три основных типа:

---

### 1. **Обычные файлы**

Это те файлы, которые чаще всего используются пользователями. Например:

- **Текстовые файлы** (документы, скрипты, конфигурации).
- **Исполняемые файлы** (программы и команды).
- **Архивы** (.zip, .tar.gz).
- **Файлы библиотек** (например, .so — аналог .dll в Windows).
- **Мультимедийные файлы** (картинки, видео, аудио).

Особенности:

- Они хранят данные.
- Расширения файлов (.txt, .png) используются для удобства, но система на них не опирается.

Пример: `file myfile.txt` — покажет, что это за тип файла.

---

### 2. **Специальные файлы**

Это файлы, которые больше нужны системе, чем пользователю. Они связаны с устройствами и взаимодействием процессов.

- **Блочные файлы**  
    Для работы с устройствами, которые читают или пишут данными блоками (например, жёсткие диски).  
    Пример: `/dev/sda` — файл для работы с жёстким диском.
    
- **Символьные файлы**  
    Обеспечивают передачу данных "по символу" (например, с клавиатуры или мыши).  
    Пример: `/dev/tty` — файл для терминала.
    
- **Символические ссылки**  
    Указывают на другой файл или каталог (что-то вроде ярлыков).  
    Пример: `ln -s file1 link_to_file1`.
    
- **Каналы (туннели)**  
    Используются для связи между программами. Например, передать результат одной команды на вход другой.  
    Пример: команда `echo "Hello" | grep H` использует канал.
    
- **Сокеты**  
    Файлы для обмена данными между процессами, даже через сеть.  
    Пример: файлы для сетевых соединений.
    

---

### 3. **Каталоги**

Это те же файлы, но они содержат ссылки на другие файлы и каталоги.  
Особенности:

- Каталоги организуют всё в иерархию (папки и подпапки).
- Корневой каталог — `/`, откуда начинается вся файловая система.  
    Пример: каталог `/home/user` содержит файлы пользователя.

---

### Кратко:

- **Обычные файлы**: текст, программы, медиа и т.д.
- **Специальные файлы**: для устройств, взаимодействия процессов и ссылок.
- **Каталоги**: "папки", которые организуют файлы в систему.

Теперь ты знаешь, как всё организовано в Linux! 😊

26. ==Понятия логического диска и тома. Форматирование тома. Понятие кластера в файловой системе.==
#### **Логический диск**

- Это непрерывная область памяти на физическом носителе.
- Все блоки идут один за другим, без "разрывов".
- Пример: раздел жёсткого диска, который вы видите как "диск C:" в Windows.

---

#### **Том**

- Это виртуальная область памяти, которая может быть составлена из блоков, разбросанных по разным местам или даже разным дискам.
- Том позволяет объединить несколько физических устройств или частей устройств в одну "виртуальную" область.
- **Пример:** RAID-массив — объединяет несколько дисков в один том для большей скорости или надёжности.

**Разница:**

- Логический диск — это всегда цельный участок памяти.
- Том — может быть собран из разных кусочков, даже с разных устройств.

---

#### **Форматирование тома**

**Форматирование тома** — это процесс подготовки устройства хранения данных (например, жесткого диска, SSD, или раздела) для использования операционной системой. Во время форматирования создается структура данных, которая позволяет системе эффективно управлять файлами и данными на этом устройстве.

Процесс форматирования включает следующие шаги:

### 1. **Создание файловой системы**:

- Во время форматирования на томе создается **файловая система**, которая управляет размещением данных на диске. Это включает в себя разделение пространства на **блоки** или **кластеры**, которые будут использоваться для хранения файлов.
- Примеры файловых систем: **ext4**, **NTFS**, **FAT32**, **Btrfs** и другие.

### 2. **Создание структуры данных (например, i-нодов)**:

- В процессе форматирования создаются специальные структуры, такие как **i-ноты (inodes)**, которые содержат метаданные о файлах, например, информацию о владельце, разрешениях на доступ, размерах, датах последнего изменения, а также указатели на физические места хранения данных.
- i-ноты позволяют файловой системе эффективно отслеживать и управлять файлами.

### 3. **Разделение на тома (если необходимо)**:

- Если на устройстве есть несколько разделов, то при форматировании этих разделов можно создать отдельные **тома** — виртуальные устройства, которые могут быть монтированы и использованы отдельно.
- Например, можно создать том для системных файлов, том для данных пользователей и том для резервных копий.

### 4. **Удаление данных**:

- Все данные на томе будут **удалены** при форматировании, поскольку на этом этапе стираются предыдущие данные и создается новая файловая структура. Однако, если форматирование не проводится в режиме низкоуровневого стирания, данные могут быть восстановлены.

---

#### **Кластер**

- Это группа секторов на диске (сектора — самые маленькие части памяти на носителе).
- Когда вы записываете файл, система выделяет ему кластеры.

**Пример:**

- Если кластер 4 КБ, а файл 1 КБ, то оставшиеся 3 КБ в этом кластере будут пустовать. Это называется **внутренней фрагментацией**.

**Размер кластера**:

- **Маленькие кластеры:** Меньше потерь памяти, но сложнее управлять (больше кластеров для одного файла).
- **Большие кластеры:** Легче управлять, но больше памяти тратится впустую.

27.==Права доступа к файлам в UNIX-системах. Команды для управления правами доступа к файлам.==
В Linux для управления файлами и каталогами используются владельцы, разрешения и специальные права доступа, которые определяют, кто и как может работать с этими файлами и каталогами.

### 1. **Владельцы файлов и каталогов:**

У каждого файла или каталога есть два владельца:

- **Пользователь** — тот, кто создал файл или каталог, и который является владельцем этого объекта.
- **Группа** — группа пользователей, к которой принадлежит этот пользователь и которая также становится владельцем файла или каталога.

Пример: если пользователь **linda** создает каталог `/home/account`, то:

- **linda** станет владельцем файла.
- Группа, в которую входит **linda**, станет владельцем группы файла.

Чтобы увидеть владельцев файла или каталога, можно использовать команду `ls -l`. Она покажет владельца и группу в начале строки:

```bash
ls -l /home/account
```

### 2. **Команда для изменения владельца:**

Для изменения владельца и группы файла в Linux используется команда `chown`:

```bash
chown кто что
```

Пример: Чтобы изменить владельца каталога `/home/account` на пользователя **linda**, используем команду:

```bash
chown linda /home/account
```

Для изменения только группы можно использовать команду `chgrp`, например:

```bash
chgrp group_name /home/account
```

### 3. **Разрешения файлов:**

В Linux файлы и каталоги имеют три основных типа разрешений:

- **r** (read) — разрешение на чтение (для файлов это означает возможность просмотра содержимого, для каталогов — просмотр содержимого каталога).
- **w** (write) — разрешение на запись (для файлов это означает возможность изменять файл, для каталогов — возможность создавать/удалять файлы в каталоге).
- **x** (execute) — разрешение на выполнение (для файлов это означает возможность выполнять файл как программу, для каталогов — возможность заходить в каталог).

Разрешения применяются к трем категориям:

- **u** (user) — владелец файла.
- **g** (group) — группа владельца.
- **o** (other) — все остальные пользователи.

Пример использования команды `chmod`: Чтобы установить права доступа к файлу, используется команда `chmod`. Например:

```bash
chmod 777 /somefile
```

Это устанавливает полные права (чтение, запись, выполнение) для владельца, группы и остальных пользователей.

### 4. **Числовое представление прав доступа:**

Разрешения могут быть записаны в числовом виде. Каждое разрешение (r, w, x) имеет свой числовой эквивалент:

- **r** = 4
- **w** = 2
- **x** = 1

Числовое представление прав доступа — это сумма значений для пользователя, группы и остальных. Например:

- **777** — полный доступ для всех (rwx для владельца, группы и других).
- **512** — разрешение на чтение и выполнение для владельца, выполнение для группы и чтение для остальных.

### 5. **Расширенные права доступа:**

В Linux существуют специальные расширенные права, которые можно назначить с помощью команды `chmod`. Это позволяет управлять дополнительными возможностями безопасности и организации работы с файлами.

- **SUID (Set User ID)** — когда файл с установленным SUID будет выполнен, процесс будет работать от имени владельца файла, а не пользователя, который его запустил. Это полезно для файлов, которые должны выполняться с правами владельца (например, `/bin/passwd`).
    - Для установки SUID используется число 4.
- **SGID (Set Group ID)** — когда файл с установленным SGID будет выполнен, процесс будет работать с правами группы владельца файла.
    - Для установки SGID используется число 2.
- **Sticky-bit** — это специальный флаг, который используется в каталогах, чтобы предотвратить удаление или изменение файлов пользователями, которые не являются владельцами этих файлов. Обычно используется в каталогах, где несколько пользователей могут работать (например, `/tmp`).
    - Для установки Sticky-bit используется число 1.

Пример использования расширенных прав: Чтобы установить SUID, SGID и Sticky-bit на каталог `/somedir`, можно использовать команду:

```bash
chmod 2755 /somedir
```

В этом примере:

- **2** — устанавливает SGID.
- **7** — для владельца разрешения на чтение, запись и выполнение.
- **5** — для группы разрешение на чтение и выполнение.
- **5** — для остальных пользователей разрешение на чтение и выполнение.

### Заключение:

- **Владельцы файлов** в Linux — это пользователи и группы, которым принадлежат файлы.
- **Команды** `chown` и `chgrp` позволяют изменять владельца и группу файлов.
- **Команда `chmod`** используется для установки и изменения разрешений, включая расширенные права (SUID, SGID и Sticky-bit).

28. ==Представление устройств как файлов.==
В UNIX-подобных операционных системах, включая Linux, устройства представлены как **специальные файлы**. Это позволяет системе и программам взаимодействовать с физическими устройствами через стандартные файловые операции, такие как чтение, запись и открытие.

### Типы специальных файлов устройств:

1. **Блочные устройства (block devices)**:
    
    - Эти устройства работают с данными блоками (например, диски или дисководы). Блоки — это фиксированные по размеру единицы данных, которые передаются за один раз.
    - Пример: `/dev/sda`, `/dev/sdb` (жёсткие диски), `/dev/nvme0n0` (NVMe-устройства).
2. **Символьные устройства (character devices)**:
    
    - Эти устройства обрабатывают данные по одному символу за раз, не используя буферизацию. Такие устройства обеспечивают более прямой и быстрый доступ.
    - Пример: последовательные порты, терминалы.

### Примеры специальных файлов устройств:

- **/dev/sda, /dev/sdb** — это файлы, представляющие жёсткие диски. Они могут быть использованы для доступа к данным на диске.
- **/dev/nvme0n0** — это файл для устройства NVMe (новый стандарт быстрого хранения данных).
- **/dev/mmcblk0** — это файл, представляющий SD-карту или другие флеш-накопители.

### Псевдоустройства:

Некоторые устройства не соответствуют реальным физическим объектам, но они предоставляют важные функции:

1. **/dev/null** — "черная дыра", куда можно записывать данные, и они просто исчезнут. Часто используется для игнорирования выводов команд.
    
    Пример:
    
    ```bash
    echo "Текст" > /dev/null  # Текст будет проигнорирован
    ```
    
2. **/dev/zero** — представляет собой источник нулевых байтов. Используется, например, для создания пустых файлов или для записи нулей на диск.
    
    Пример:
    
    ```bash
    dd if=/dev/zero of=/dev/sda  # Заполнение всего диска нулями
    ```
    
3. **/dev/tty** — это виртуальный терминал или последовательный порт, который позволяет взаимодействовать с текущей консолью системы.
    
4. **/dev/random** — устройство, генерирующее случайные числа, которые могут использоваться, например, для криптографических операций.
    
    Пример:
    
    ```bash
    cat /dev/random  # Вывод случайных данных
    ```
    

### Важность специальных файлов устройств:

- **Специальные файлы устройств** предоставляют стандартный интерфейс для работы с аппаратными средствами. Это позволяет пользователям и программам использовать устройства, как обычные файлы.
- Они лежат в каталоге **/dev**, который является частью файловой системы и доступен для работы с устройствами.

29. ==Типы и атрибуты процессов в UNIX-системах.==
В UNIX-системах процессы — это активные экземпляры программ. Они имеют уникальные идентификаторы, атрибуты и состояния. Рассмотрим основные аспекты:

---

### **Типы процессов**

1. **Пользовательские процессы**:
    
    - Запускаются от имени обычного пользователя.
    - Работают в пользовательском пространстве.
    - Ограничены в доступе к системным ресурсам, кроме тех, к которым имеет доступ пользователь.
2. **Процессы-демоны**:
    
    - Работают в фоновом режиме и выполняют задачи без участия пользователя.
    - Примеры: веб-серверы (`apache2`), системные службы.
    - Часто запускаются от имени системных пользователей или `root`.
3. **Процессы ядра**:
    
    - Выполняются в пространстве ядра, имеют полный доступ к системным ресурсам.
    - Работают с устройствами, драйверами и системными функциями.
    - Изменение их поведения часто требует перекомпиляции ядра.

---

### **Атрибуты процессов**

Каждый процесс имеет множество атрибутов, среди которых:

- **PID (Process ID)**: уникальный идентификатор процесса.
- **PPID (Parent Process ID)**: идентификатор родительского процесса.
- **UID/GID**: пользователь и группа, запустившие процесс.
- **EUID/EGID**: эффективный пользователь и группа, от имени которых работает процесс.
- **TTY**: терминал, связанный с процессом (если есть).
- **PRI (Priority)**: приоритет выполнения процесса.
- **NI (Niceness)**: значение, влияющее на приоритет (`PRI`); изменяемо только суперпользователем.
- **PGID**: группа процессов.
- **SID**: идентификатор сеанса.
- **Состояние**: текущее состояние выполнения (см. ниже).

---

### **Состояния процессов**

1. **R (Running/Ready)**: процесс выполняется на процессоре или готов к выполнению.
2. **S (Sleeping)**: процесс ожидает ресурсы (например, ввод-вывод).
3. **D (Uninterruptible Sleep)**: процесс ожидает завершения операции с устройством, игнорирует сигналы.
4. **I (Idle)**: бездействующий поток ядра.
5. **T (Stopped)**: процесс остановлен сигналом или отладчиком.
6. **Z (Zombie)**: процесс завершён, но его PID ещё не освобождён родительским процессом.

---

### **Инструменты для управления процессами**

1. **top/htop**:
    
    - Интерактивные утилиты для мониторинга процессов в реальном времени.
    - Показывают загрузку процессора, памяти, состояние процессов.
2. **ps**:
    
    - Неинтерактивная утилита для получения списка процессов.
    - Используется для детального анализа атрибутов процессов.
3. **kill**:
    
    - Команда для отправки сигналов процессам (например, завершения).
4. **nice/renice**:
    
    - Управляют приоритетом процессов.

---

### **Пример использования**

- Показать все процессы текущего пользователя:
    
    ```bash
    ps -u $(whoami)
    ```
    
- Отобразить процессы в реальном времени:
    
    ```bash
    top
    ```
    
- Установить высокий приоритет для процесса:
    
    ```bash
    renice -10 <PID>
    ```

30. ==.Процессы в POSIX-системах. Типы процессов, атрибуты процессов, порождение нового процесса. Команды для работы с процессами==
  
Процесс в POSIX-системах - это вычисления по программе, выполняемые в собственном виртуальном адресном пространстве, т.е. понятие процесса в POSIX-системах почти ничем не отличается от такового в других ОС. Главное отличие — это механизм порождения нового процесса и получения необходимых ресурсов. 

(Вот это важно, по сути - ответ на этот вопрос аналогичен 29-му, разница только в этом)

Если в большинстве ОС процессы запрашивают ресурсы у операционной системы, то в POSIX-системах процессы наследуют ресурсы у своих процессов-родителей, т. е. тех процессов, которые их породили (создали и запустили).  
Для образования нового процесса и запуска в нем программы используются два системных вызова POSIX API — это fork() и exec(имя выполняемого файла). Системный вызов fork приводит к созданию нового образа, состояние которого абсолютно идентично состоянию адресного пространства основного процесса (то есть в нем содержатся те же программы и данные). Для дочернего процесса заводятся копии всех сегментов данных

Любой процесс, независимо от того — системный ли он, пользовательский, интерактивный или неинтерактивный, имеет несколько атрибутов, основными являются следующие:  

- идентификатор процесса (PID — Process IDentifier);  
    
- идентификатор родительского процесса (PPID — Parent PID);  
    
- имя пользователя - владельца процесса;  
    
- идентификатор владельца процесса (UID); 
    
- идентификатор группы владельца (GUID);  
    
- приоритет; 
    
-  номер терминала, к которому привязан процесс
    

Таким образом, процесс в POSIX-системах является объектом, создаваемым в результате выполнения функции fork(). Каждый процесс, за исключением начального (нулевого) порождается в результате запуска другим процессом операции fork(). Каждый процесс имеет одного родителя, но может породить много процессов. Начальный (нулевой) процесс является особенным процессом, который создается в результате загрузки системы. После порождения нового процесса с идентификатором 1 нулевой процесс становится процессом подкачки и реализует механизм виртуальной памяти. Процесс с идентификатором 1, известный под именем init, является предком любого другого процесса в системе и связан с каждым процессом особым образом.

  
Блять, пойди пойми ещё это…

По поводу команд - доступные ламерам перечислены в 29-м вопросе

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfF3AvITz5v6DCx9kZn43FUQsBQqPoi3SdlvHJCr-_vKDbddPOjJDqkXM6BY1tYgMKSkgrEYxYl0JIWPySlRGT_6CnItXyGJVZTgKMmO2nKZM-LZKc4KCexly1rpAF1rKBb0Mi_ZQ?key=Z1XIdrVGs9BAzVVZHveVCgYL)  
Потные низкоуровневые помимо fork() для создания дочернего процесса как копии текущего для параллельного выполнения есть:  
  
exec() - заменяет адресное пространство процесса новым исполняемым файлом. Используется для запуска нового приложения в контексте текущего процесса.

wait() - родительский процесс может ожидать завершения дочернего с помощью этих вызовов.

31. ==Пользователи и группы. Атрибуты пользователя. Основные команды для работы с учётными записями пользователей.==
В Linux всё делается от имени пользователей. У каждого есть своя учетная запись с правами и ограничениями. Вот основные моменты:

---

### **Кто такие пользователи в Linux?**

1. **Администраторы (root)**:
    
    - Полный доступ к системе.
    - По умолчанию есть один администратор — `root`.
2. **Обычные пользователи**:
    
    - Ограниченный доступ (работают только с тем, что разрешено).
    - Эти учетные записи создаёт администратор.
3. **Системные пользователи**:
    
    - Создаются системой для работы программ (например, `www-data` для веб-сервера).
    - Они не логинятся как обычные пользователи.

---

### **ID пользователей (UID)**

Каждому пользователю присваивается уникальный номер (UID):

- Администратор: UID = 0.
- Обычные пользователи: UID от 1000 и больше.
- Системные пользователи: UID от 1 до 999.

---

### **Группы в Linux**

- Группы — это способ объединить пользователей для удобного управления правами.
- Пользователь может быть в нескольких группах.
- Если для пользователя не указать группу, ему создаётся личная группа с его именем.

---

### **Как добавить пользователя?**

1. **Создать нового пользователя**:
    
    ```bash
    sudo useradd имя_пользователя
    ```
    
2. **Задать пароль**:
    
    ```bash
    sudo passwd имя_пользователя
    ```
    
3. **Изменить настройки существующего пользователя**:
    
    ```bash
    sudo usermod [опция] имя_пользователя
    ```
    
    Например, чтобы сменить домашнюю папку:
    
    ```bash
    sudo usermod -d /new/home имя_пользователя
    ```
    
4. **Удалить пользователя**:
    
    ```bash
    sudo userdel имя_пользователя
    ```
    

---

### **Как узнать, что пользователь активен или чем он занят?**

- Проверить, запущены ли процессы пользователя:
    
    ```bash
    pgrep -l -u имя_пользователя
    ```
    
- Убедиться, что пользователь сейчас не авторизован:
    
    ```bash
    pinky имя_пользователя
    ```
    

---

### **Где хранится информация о пользователях?**

Все данные о пользователях находятся в файле:

```bash
/etc/passwd
```

---

### **Что нельзя делать с именами пользователей?**

- Имя не может начинаться с тире или состоять только из цифр.
- Оно может содержать буквы, цифры, символы `_`, `-` и точку.
- Максимум 32 символа.

---

Пример: чтобы создать пользователя `test-user`, задать ему пароль и добавить его в группу `developers`:

```bash
sudo useradd test-user
sudo passwd test-user
sudo usermod -aG developers test-user
```

Теперь этот пользователь будет с нужными правами и доступами!

32. ==Учетные записи групп. Основные команды для работы с учетными записями групп.==
**

Учётные записи групп в UNIX и подобных системах обеспечивают механизм управления доступом к ресурсам для нескольких пользователей одновременно. Группа объединяет пользователей, которым необходимо совместное использование файлов или других ресурсов.

Информация об основной группе пользователя хранится в файле /etc/passwd. Пользователь также может принадлежать и к другим группам, информация об этом указана в /etc/group. Структура этого файла такая:  
Имя_группы : Групповой_пароль : GID : Список_пользователей Групповой пароль в настоящее время не используется и обычно имеет значение х или *. GID представляет собой уникальный числовой идентификатор группы. Список пользователей представляет собой перечисленные через запятую имена пользователей (точнее, их логины), для которых эта группа является дополнительной. Основные команды для работы с учётными записями групп (требуют права суперпользователя) 

groupadd group_name - создание группы с названием group_name  
groupadd -g GID group_name - создание группы с названием group_name и GID равным указанному GID  
usermod -g group_name user_name - изменение первичной группы пользователя  
groupdel group_name  
groupmod -n new_group_name old_group_name - переименовать группу  
usermod -aG group_name user_name - добавить пользователя в группу (а для сохранения уже имеющихся групп, типа append)  
gpasswd -d user_name group_name - удалить пользователя из группы  
groups user_name - посмотреть все группы пользователя  
  


**

34. ==Дистрибутивы и репозитории GNU/Linux. Пакеты программ и менеджеры пакетов.==
### **Что такое дистрибутив Linux?**

Дистрибутив Linux — это сборка операционной системы, включающая ядро Linux и набор программ. У каждого дистрибутива свои особенности, цели и программы. Примеры популярных дистрибутивов:

- **Debian, Ubuntu, Mint** — для новичков и повседневного использования.
- **Arch, Gentoo** — для опытных пользователей, которым нравится всё настраивать вручную.
- **Red Hat, Fedora, openSUSE** — для серверов и бизнеса.
- **Kali** — для тестирования безопасности.
- **Astra** — российская разработка для госструктур.
- Даже **Android** можно назвать дистрибутивом Linux.

### **Что такое репозиторий?**

Репозиторий — это онлайн-хранилище программ для дистрибутива. Это как магазин приложений, только для Linux. Репозитории содержат пакеты с программами, которые можно устанавливать, обновлять или удалять.

Репозитории обычно официальные и находятся на серверах дистрибутива, но иногда бывают сторонние (например, программы с GitHub).

---

### **Что такое пакет программ?**

Пакет — это набор файлов, из которых состоит программа. В пакете могут быть:

- Исполняемый файл программы.
- Библиотеки, которые нужны для её работы.
- Информация о зависимостях (других пакетах, которые нужны для запуска программы).

Пример: пакет браузера может включать сам браузер, а также файлы для отображения веб-страниц.

---

### **Менеджеры пакетов**

Менеджер пакетов — это программа, которая помогает устанавливать, обновлять и удалять другие программы.

#### Что умеет менеджер пакетов?

1. **Устанавливать программы** (и автоматически докачивать всё, что нужно для их работы).
2. **Обновлять программы** до новых версий.
3. **Удалять программы** и ненужные файлы, которые остались после них.
4. **Искать программы** в репозиториях.
5. **Добавлять новые репозитории** или настраивать уже существующие.

#### Примеры менеджеров пакетов:

- **apt** — для дистрибутивов на базе Debian (например, Ubuntu, Mint).
- **pacman** — для дистрибутивов на базе Arch.

---

### **Пример использования менеджера пакетов (на примере apt):**

1. **Установка программы**:
    
    ```bash
    sudo apt install имя_пакета
    ```
    
    Например:
    
    ```bash
    sudo apt install firefox
    ```
    
2. **Обновление всех программ**:
    
    ```bash
    sudo apt update && sudo apt upgrade
    ```
    
3. **Удаление программы**:
    
    ```bash
    sudo apt remove имя_пакета
    ```
    
4. **Поиск программы**:
    
    ```bash
    apt search имя_пакета
    ```
    
5. **Добавление нового репозитория** (пример):
    
    ```bash
    sudo add-apt-repository ppa:имя_репозитория
    ```
    

Теперь вы знаете, что дистрибутивы и менеджеры пакетов делают работу в Linux удобной и организованной!

35. ==Стек протоколов TCP/IP и модель взаимодействия открытых систем (OSI). RFC-документы, типы этих документов.==
**

Стек протоколов TCP/IP был создан до появления модели взаимодействия открытых систем и, тем более, намного раньше собственно стека протоколов OSI. Поэтому его архитектура получилась существенно проще и вместо семи уровней он имеет только четыре. Причём самый нижний уровень в стеке TCP/IP вообще не специфицирован, т. е. фактически имеются свои протоколы только для трёх уровней.

Соответствие уровней эталонной модели стека TCP-IP уровням эталонной модели OSI:

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeS-VA64JzC-RDm4ySI7xAT4N74TTvPaKd_npDIo0UNjjO_s_KFUvsDVNz4iaAJqk20tE3ADBJk6rJ_Jk3b4qyNKrIxRYYwADCA_wsU494GMuBpVOiTjFO8h7_yKr5dzp9uMn-emg?key=Z1XIdrVGs9BAzVVZHveVCgYL)

Стек протоколов TCP/IP состоит из нескольких уровней, каждый из которых выполняет определённые задачи:

1. Уровень приложений включает широкий спектр протоколов для взаимодействия приложений. Сюда входят протоколы для работы с файлами (FTP, TFTP, NFS), удалённого управления (Telnet, SSH), графического интерфейса (X Window, VNC), электронной почты (SMTP, POP3, IMAP) и гипертекста (HTTP, HTTPS).
    

Также на этом уровне работают протоколы для управления сетевыми устройствами (SNMP), системы доменных имён (DNS) и конфигурирования узлов (DHCP). 

2. Транспортный уровень обеспечивает передачу данных. Протокол TCP гарантирует доставку, сохраняя порядок пакетов, в то время как UDP подходит для работы в реальном времени, где задержки нежелательны. Более новые протоколы, такие как SCTP и DCCP, добавляют функции многопоточности и контроля перегрузок. 
    
3. Межсетевой уровень отвечает за маршрутизацию и адресацию с использованием протокола IP, а также включает ICMP для обмена служебными сообщениями и протоколы маршрутизации, такие как RIP и OSPF. 
    
4. Уровень сетевого интерфейса, в отличие от других, не имеет собственных протоколов в TCP/IP и использует драйверы сетевых устройств и любые сетевые технологии.
    

Стек TCP/IP отличается от модели OSI тем, что объединяет функции некоторых её уровней: уровень приложений TCP/IP включает задачи приложений, представлений и сеансов OSI, транспортный уровень соответствует транспортному OSI, межсетевой аналогичен сетевому, а уровень интерфейсов объединяет канальный и физический уровни OSI.

RFC (Request for Comments — запрос на комментарии) представляет собой и документ, и способ распространения информации, хранящейся на общедоступном сервере. Документы RFC имеют последовательную нумерацию, поэтому при появлении нового документа он просто получает новый порядковый номер. В каждом документе в его начале перечисляются все те основные RFC-документы, на основании которых появился новый. Важно отметить, что эти документы по своей сути представляют собой стандарты Интернета, и они имеют разный статус.

Не знаю, насколько нужны жизненные циклы стандартов Интернета, но поскольку ни в одном билете этого нет, а на лекциях об этом рассказывалось, думаю, что он может спросить об этом здесь

Согласно RFC 2026, жизненный цикл стандарта выглядит следующим образом:

1. Выносится на всеобщее рассмотрение Интернетовский черновик (Internet Draft). Черновики не имеют официального статуса, и удаляются из базы через шесть месяцев после последнего изменения.
    
2. Если черновик стандарта оказывается достаточно удачным и непротиворечивым, он получает статус Предложенного стандарта (Proposed Standard), и свой номер RFC. Наличие программной реализации стандарта желательно, но не обязательно.
    
3. Следующая стадия — Черновой стандарт (Draft Standard) означает, что предложенный стандарт принят сообществом, в частности, существуют две независимые по коду совместимые реализации разных команд разработчиков. В черновые стандарты ещё могут вноситься мелкие правки, но они считаются достаточно стабильными и рекомендуются для реализации.
    
4. Высший уровень — Стандарт Интернета (Internet Standard). Это спецификации с большим успешным опытом применения и зрелой формулировкой. Параллельно с нумерацией RFC они имеют свою собственную нумерацию STD. Список стандартов имеется в документе STD 1 (сейчас это RFC 5000, но нумерация может измениться). Из более чем трёх тысяч RFC-документов этого уровня достигли только несколько десятков.
    
5. Многие старые RFC замещены более новыми версиями под новыми номерами, или вышли из употребления. Такие документы получают статус Исторических стандартов (Historic).
    

  

Практически все стандарты Интернета существуют в виде опубликованных заявок RFC. Но в виде документов RFC выходят не только стандарты, но также концепции, введения в новые направления в исследованиях, исторические справки, результаты экспериментов, руководства по внедрению технологий, предложения и рекомендации по развитию существующих Стандартов и другие новые идеи в информационных технологиях:

- Экспериментальные (Experimental) спецификации содержат информацию об экспериментальных исследованиях, интересных для интернет-сообщества. Это могут быть, например, прототипы, реализующие новые концепции.
    
- Информационные (Informational) RFC-документы предназначены для ознакомления общественности, не являются стандартами и не являются результатом консенсуса или рекомендациями. Некоторые черновики, не получившие статуса Предложенного стандарта, но представляющие интерес, могут быть опубликованы как Информационные RFC.
    
- Лучший современный опыт (Best Current Practice). Эта серия RFC-документов содержит рекомендации по реализации стандартов, в том числе от сторонних организаций, а также внутренние документы о структуре и процедурах стандартизации.
    

**